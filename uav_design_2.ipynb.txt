{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bdbfad5b",
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install scipy==1.9.3 --force-reinstall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "dcdf4460",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import scipy\n",
    "# def derivative(func, x0, dx=1e-6, n=1, order=3):\n",
    "#     if n != 1 or order != 3:\n",
    "#         raise NotImplementedError(\"Only n=1 and order=3 supported\")\n",
    "#     return (func(x0 + dx) - func(x0 - dx)) / (2 * dx)\n",
    "\n",
    "# scipy.misc.derivative = derivative\n",
    "\n",
    "import math\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from scipy.interpolate import interp1d\n",
    "from ADRpy import atmospheres as at\n",
    "from importlib import reload\n",
    "import helper_functions\n",
    "helper_functions = reload(helper_functions)\n",
    "from helper_functions import *\n",
    "import specs\n",
    "specs = reload(specs)\n",
    "from specs import *\n",
    "import subprocess\n",
    "import os\n",
    "from airfoils import Airfoil"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "cd146068",
   "metadata": {},
   "outputs": [],
   "source": [
    "foil = Airfoil.NACA4('2412')\n",
    "x,y = foil.all_points"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "ebaebb3d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def save_airfoil_as_dat(filename, name, x, y):\n",
    "    \"\"\"\n",
    "    Save airfoil coordinates to a .dat file in Selig format.\n",
    "\n",
    "    Parameters:\n",
    "        filename (str): Path to save the file (e.g., 'NACA2412.dat')\n",
    "        name (str): Airfoil name to be written as the first line\n",
    "        x (array-like): x-coordinates\n",
    "        y (array-like): y-coordinates\n",
    "    \"\"\"\n",
    "    with open(filename, 'w') as f:\n",
    "        f.write(f\"   {name}\\n\")\n",
    "        for xi, yi in zip(x, y):\n",
    "            f.write(f\"  {xi:8.5f}     {yi:8.5f}\\n\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "ba5dad50",
   "metadata": {},
   "outputs": [],
   "source": [
    "save_airfoil_as_dat(\"naca2412_coords.dat\", \"NACA2412\", x, y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "13aca354",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_aerodynamic_coeffs_for_airfoil(correct_airfoil_name_with_space, from_dat=False):\n",
    "    xfoil_path = os.path.join(os.getcwd(), r\"XFOIL6.99\\xfoil.exe\")\n",
    "\n",
    "    # Define the commands to be sent to XFOIL\n",
    "    commands = f\"\"\"\n",
    "    {correct_airfoil_name_with_space}\n",
    "    OPER\n",
    "    VISC 1000000\n",
    "    PACC\n",
    "    {correct_airfoil_name_with_space}.dat\n",
    "\n",
    "    ASEQ -5 15 0.1\n",
    "\n",
    "    QUIT\n",
    "    \"\"\"\n",
    "    if from_dat:\n",
    "        commands = f\"\"\"\n",
    "    LOAD {correct_airfoil_name_with_space}.dat\n",
    "    PANE\n",
    "    OPER\n",
    "    VISC 1000000\n",
    "    PACC\n",
    "    {correct_airfoil_name_with_space}-polar.dat\n",
    "\n",
    "    ASEQ -5 15 0.1\n",
    "\n",
    "    QUIT\n",
    "    \"\"\"\n",
    "\n",
    "    print(commands)\n",
    "    # Write the commands to a temporary file\n",
    "    with open('xfoil_input.txt', 'w') as f:\n",
    "        f.write(commands)\n",
    "\n",
    "    # Execute XFOIL with the input file\n",
    "    with open('xfoil_input.txt', 'r') as input_file, open('xfoil_output.txt', 'w') as output_file:\n",
    "        subprocess.run(xfoil_path, stdin=input_file, stdout=output_file)\n",
    "\n",
    "def load_xfoil_polar(filepath):\n",
    "    with open(filepath, 'r') as f:\n",
    "        lines = f.readlines()\n",
    "\n",
    "    data_lines = []\n",
    "    start_collecting = False\n",
    "\n",
    "    for line in lines:\n",
    "        line = line.strip()\n",
    "\n",
    "        # Identify the line with column headers\n",
    "        if line.startswith(\"alpha\") and \"CL\" in line:\n",
    "            start_collecting = True\n",
    "            continue\n",
    "\n",
    "        # Skip lines until data starts\n",
    "        if start_collecting:\n",
    "            # Stop if blank line or end of numeric data\n",
    "            if not line or not any(char.isdigit() for char in line):\n",
    "                continue\n",
    "\n",
    "            # Try to parse the data\n",
    "            try:\n",
    "                parts = line.split()\n",
    "                if len(parts) == 7:\n",
    "                    alpha, cl, cd, cdp, cm, top_xtr, bot_xtr = map(float, parts)\n",
    "                    data_lines.append([alpha, cl, cd, cdp, cm, top_xtr, bot_xtr])\n",
    "            except ValueError:\n",
    "                continue  # Skip malformed lines\n",
    "\n",
    "    df = pd.DataFrame(data_lines, columns=[\"alpha\", \"CL\", \"CD\", \"CDp\", \"CM\", \"Top_Xtr\", \"Bot_Xtr\"])\n",
    "    return df\n",
    "\n",
    "def get_coefficients_at_alpha(df, alpha):\n",
    "    \"\"\"\n",
    "    Interpolate aerodynamic coefficients from XFOIL polar DataFrame.\n",
    "\n",
    "    Parameters:\n",
    "        df (pd.DataFrame): Must contain 'alpha', 'CL', 'CD', 'CDp', 'CM', 'Top_Xtr', 'Bot_Xtr'\n",
    "        alpha (float): Angle of attack in degrees\n",
    "\n",
    "    Returns:\n",
    "        dict: Interpolated coefficients at the specified alpha\n",
    "    \"\"\"\n",
    "    if df.empty:\n",
    "        raise ValueError(\"Input DataFrame is empty\")\n",
    "\n",
    "    # Ensure the DataFrame is sorted by alpha\n",
    "    df_sorted = df.sort_values(\"alpha\")\n",
    "\n",
    "    # Check alpha bounds\n",
    "    if not (df_sorted[\"alpha\"].min() <= alpha <= df_sorted[\"alpha\"].max()):\n",
    "        raise ValueError(f\"Alpha {alpha} is out of bounds ({df_sorted['alpha'].min()} to {df_sorted['alpha'].max()})\")\n",
    "\n",
    "    # Interpolate each column\n",
    "    coeffs = {}\n",
    "    for col in [\"CL\", \"CD\", \"CDp\", \"CM\", \"Top_Xtr\", \"Bot_Xtr\"]:\n",
    "        coeffs[col] = np.interp(alpha, df_sorted[\"alpha\"], df_sorted[col])\n",
    "\n",
    "    coeffs[\"alpha\"] = alpha\n",
    "    return coeffs\n",
    "\n",
    "def get_cl_alpha_at(df, alpha, delta=0.5):\n",
    "    \"\"\"\n",
    "    Approximates the local lift curve slope dCl/dα at a specified angle of attack.\n",
    "\n",
    "    Parameters:\n",
    "        df (pd.DataFrame): Polar data with columns 'alpha' and 'CL'\n",
    "        alpha (float): Angle of attack in degrees at which to compute the slope\n",
    "        delta (float): Small delta around alpha for finite difference (in degrees)\n",
    "\n",
    "    Returns:\n",
    "        float: Estimated dCl/dα (1/deg)\n",
    "    \"\"\"\n",
    "    df = df.sort_values(\"alpha\")\n",
    "\n",
    "    alpha_min = -5\n",
    "    alpha_max = 10\n",
    "\n",
    "    if not (alpha_min <= alpha - delta and alpha + delta <= alpha_max):\n",
    "        raise ValueError(f\"Alpha ± delta must be within data bounds ({alpha_min} to {alpha_max})\")\n",
    "\n",
    "    # Interpolate CL at alpha ± delta\n",
    "    cl_plus = np.interp(alpha + delta, df[\"alpha\"], df[\"CL\"])\n",
    "    cl_minus = np.interp(alpha - delta, df[\"alpha\"], df[\"CL\"])\n",
    "\n",
    "    cl_alpha = (cl_plus - cl_minus) / (2 * delta)\n",
    "    return cl_alpha\n",
    "\n",
    "def get_row_for_cl(df, target_cl):\n",
    "    \"\"\"\n",
    "    Interpolate the polar data to find the row corresponding to a target CL.\n",
    "\n",
    "    Parameters:\n",
    "        df (pd.DataFrame): Must contain columns 'alpha' and 'CL'\n",
    "        target_cl (float): Desired lift coefficient\n",
    "\n",
    "    Returns:\n",
    "        dict: Interpolated row with keys: alpha, CL, CD, CDp, CM, Top_Xtr, Bot_Xtr\n",
    "    \"\"\"\n",
    "    df = df.sort_values(\"CL\")\n",
    "\n",
    "    if not (df[\"CL\"].min() <= target_cl <= df[\"CL\"].max()):\n",
    "        raise ValueError(f\"CL = {target_cl} is out of bounds ({df['CL'].min()} to {df['CL'].max()})\")\n",
    "\n",
    "    # Find bracketing rows\n",
    "    lower_idx = df[df[\"CL\"] <= target_cl][\"CL\"].idxmax()\n",
    "    upper_idx = df[df[\"CL\"] >= target_cl][\"CL\"].idxmin()\n",
    "\n",
    "    row_low = df.loc[lower_idx]\n",
    "    row_high = df.loc[upper_idx]\n",
    "\n",
    "    if lower_idx == upper_idx:\n",
    "        return row_low.to_dict()  # Exact match\n",
    "\n",
    "    # Linear interpolation factor\n",
    "    t = (target_cl - row_low[\"CL\"]) / (row_high[\"CL\"] - row_low[\"CL\"])\n",
    "\n",
    "    interpolated = {}\n",
    "    for col in [\"alpha\", \"CL\", \"CD\", \"CDp\", \"CM\", \"Top_Xtr\", \"Bot_Xtr\"]:\n",
    "        interpolated[col] = (1 - t) * row_low[col] + t * row_high[col]\n",
    "\n",
    "    return interpolated\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "373439d0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# get_aerodynamic_coeffs_for_airfoil(\"s1223\", from_dat=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "b48bda8f",
   "metadata": {},
   "outputs": [],
   "source": [
    "airfoil_coeffs_vs_alpha = load_xfoil_polar('NACA 2412.dat')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "6176c769",
   "metadata": {},
   "outputs": [],
   "source": [
    "def initial_design_feasibility_pass(current_values, assumed_and_set):\n",
    "    # Unpack Inputs\n",
    "    mtow = current_values[\"mtow\"]\n",
    "    cl_cruise = current_values[\"cl_cruise\"]\n",
    "    cruise_speed_kmh = current_values[\"cruise_speed_kmh\"]\n",
    "    altitude_m = assumed_and_set.get(\"cruise_altitude_m\", 0)\n",
    "    rho = get_air_density(altitude_m)\n",
    "    v_ms = kmh_to_ms(cruise_speed_kmh)\n",
    "\n",
    "    # 1. Calculate Initial Wing Area\n",
    "    current_values[\"wing_area_m2\"] = (2 * mtow * g) / (rho * v_ms**2 * cl_cruise)\n",
    "\n",
    "    # 2. Wing Loading\n",
    "    current_values[\"wing_loading_pa\"] = (mtow * g) / current_values[\"wing_area_m2\"]\n",
    "\n",
    "    # 3. Wing Geometry\n",
    "    AR = current_values[\"aspect_ratio\"]\n",
    "    current_values[\"wing_span_m\"] = (current_values[\"wing_area_m2\"] * AR)**0.5\n",
    "    current_values[\"chord_m\"] = current_values[\"wing_area_m2\"] / current_values[\"wing_span_m\"]\n",
    "\n",
    "    # 4. Fuselage Geometry\n",
    "    fuselage_length = assumed_and_set[\"fuselage_length_mac_coeff\"] * current_values[\"chord_m\"]\n",
    "    current_values[\"fuselage_body_length_m\"] = fuselage_length\n",
    "    current_values[\"wing_le_position_m\"] = assumed_and_set[\"wing_le_position_fuselage_length_coeff\"] * fuselage_length\n",
    "\n",
    "    # 5. Tail Arm and Tail Areas\n",
    "    tail_arm = assumed_and_set[\"horizontal_tail_arm_mac_coeff\"] * current_values[\"chord_m\"]\n",
    "    current_values[\"tail_arm_m\"] = tail_arm\n",
    "    Vh = assumed_and_set[\"horizontal_tail_volume_coefficient\"]\n",
    "    Vv = assumed_and_set[\"vertical_tail_volume_coefficient\"]\n",
    "    current_values[\"horizontal_tail_area_m2\"] = Vh * current_values[\"wing_area_m2\"] * current_values[\"chord_m\"] / tail_arm\n",
    "    current_values[\"vertical_tail_area_m2\"] = Vv * current_values[\"wing_area_m2\"] * current_values[\"wing_span_m\"] / tail_arm\n",
    "\n",
    "    return current_values\n",
    "\n",
    "\n",
    "def stability_analysis(\n",
    "    chord_m,\n",
    "    cg_m,\n",
    "    tail_volume_coeff,\n",
    "    wing_le_position_m\n",
    "):\n",
    "    Vh = tail_volume_coeff\n",
    "\n",
    "    neutral_point_m = wing_le_position_m + 0.25 * chord_m + Vh * chord_m\n",
    "    static_margin = (neutral_point_m - cg_m) / chord_m\n",
    "\n",
    "\n",
    "    return {\n",
    "        \"neutral_point_m\": neutral_point_m,\n",
    "        \"static_margin\": static_margin,\n",
    "    }\n",
    "\n",
    "def cruise_trim_analysis(\n",
    "    neutral_point_m,\n",
    "    cg_from_nose,\n",
    "    cl_cruise,\n",
    "    tail_arm_m,\n",
    "    eta_h,\n",
    "):\n",
    "    cl_tail = (cg_from_nose - neutral_point_m) * cl_cruise / tail_arm_m\n",
    "    alpha_tail = get_row_for_cl(airfoil_coeffs_vs_alpha, cl_tail)[\"alpha\"]\n",
    "    cl_alpha_tail =  get_cl_alpha_at(airfoil_coeffs_vs_alpha, alpha_tail, delta=0.1) # from airfoil data at Re=500k\n",
    "\n",
    "    # print(cl_tail,alpha_tail, cl_alpha_tail)\n",
    "    delta_e_rad = cl_tail / (cl_alpha_tail * eta_h)\n",
    "    delta_e_deg = np.degrees(delta_e_rad)\n",
    "    \n",
    "    return {\n",
    "        \"cl_tail_required\": cl_tail,\n",
    "        \"delta_elevator_deg\": delta_e_deg,\n",
    "    }\n",
    "\n",
    "def tail_geometry(area_m2, aspect_ratio):\n",
    "    span_m = (area_m2 * aspect_ratio) ** 0.5\n",
    "    chord_m = area_m2 / span_m\n",
    "    return span_m, chord_m\n",
    "    \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "19a64e86",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_fuselage_mass(fuselage_length, fuselage_width, fuselage_height, assumed_and_set):\n",
    "    skin_thickness = sandwich_specs[\"fuselage\"][\"total_thickness_m\"] - sandwich_specs[\"fuselage\"][\"core_thickness_m\"]\n",
    "    skin_cross_sectional_cirfumferance = (fuselage_width + fuselage_height)\n",
    "    skin_cross_sectional_area = skin_cross_sectional_cirfumferance * skin_thickness\n",
    "    total_skin_volume = fuselage_length * skin_cross_sectional_area\n",
    "    skin_density = assumed_and_set[\"gfrp_density_kgm3\"]\n",
    "    total_skin_mass = total_skin_volume * skin_density\n",
    "    \n",
    "    core_thickness = sandwich_specs[\"fuselage\"][\"core_thickness_m\"]\n",
    "    core_cross_sectional_cirfumferance = 2 * (fuselage_width + fuselage_height)\n",
    "    core_cross_sectional_area = core_cross_sectional_cirfumferance * core_thickness\n",
    "    total_core_volume = fuselage_length * core_cross_sectional_area\n",
    "    core_density = assumed_and_set[\"core_density_kgm3\"]\n",
    "    total_core_mass = total_core_volume * core_density\n",
    "\n",
    "    total_fuselage_mass = total_skin_mass + total_core_mass\n",
    "\n",
    "    return total_fuselage_mass\n",
    "\n",
    "def airfoil_perimeter_length(x, y, chord):\n",
    "    \"\"\"\n",
    "    Compute total surface length of an airfoil given x and y coordinates.\n",
    "\n",
    "    Parameters:\n",
    "        x (array-like): x coordinates of the airfoil surface\n",
    "        y (array-like): y coordinates of the airfoil surface\n",
    "\n",
    "    Returns:\n",
    "        float: total length along the airfoil perimeter\n",
    "    \"\"\"\n",
    "    x = np.array(x)\n",
    "    y = np.array(y)\n",
    "\n",
    "    dx = np.diff(x)\n",
    "    dy = np.diff(y)\n",
    "    segment_lengths = np.sqrt(dx**2 + dy**2)\n",
    "    total_length = np.sum(segment_lengths) * chord\n",
    "    \n",
    "    return total_length\n",
    "\n",
    "def get_wing_or_tail_mass(span, cross_section_perimeter_length, tail_or_wing, assumed_and_set):\n",
    "\n",
    "    \n",
    "    skin_thickness = sandwich_specs[tail_or_wing][\"total_thickness_m\"] - sandwich_specs[tail_or_wing][\"core_thickness_m\"]\n",
    "    skin_cross_sectional_cirfumferance = cross_section_perimeter_length\n",
    "    skin_cross_sectional_area = skin_cross_sectional_cirfumferance * skin_thickness\n",
    "    total_skin_volume = span * skin_cross_sectional_area\n",
    "    skin_density = assumed_and_set[\"gfrp_density_kgm3\"]\n",
    "    total_skin_mass = total_skin_volume * skin_density\n",
    "    \n",
    "    core_thickness = sandwich_specs[tail_or_wing][\"core_thickness_m\"]\n",
    "    core_cross_sectional_cirfumferance = cross_section_perimeter_length\n",
    "    core_cross_sectional_area = core_cross_sectional_cirfumferance * core_thickness\n",
    "    total_core_volume = span * core_cross_sectional_area\n",
    "    core_density = assumed_and_set[\"core_density_kgm3\"]\n",
    "    total_core_mass = total_core_volume * core_density\n",
    "\n",
    "    total_wing_mass = total_skin_mass + total_core_mass\n",
    "\n",
    "    return total_wing_mass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "09daa4f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "def size_fuselage_diameter_as_per_payload(internal_payload_count, internal_payload_diameter):\n",
    "    n = internal_payload_count     # number of cylinders\n",
    "    d = internal_payload_diameter  # cylinder diameter (m)\n",
    "    s = 0.02               # spacing between cylinders (m)\n",
    "    t = 0.015              # carousel mechanism radial thickness (m)\n",
    "\n",
    "    # 1. Effective diameter\n",
    "    d_eff = d + s\n",
    "\n",
    "    # 2. Center-to-center radius\n",
    "    r_center = d_eff / (2 * math.sin(math.pi / n))\n",
    "\n",
    "    # 3. Outer radius including half the effective diameter\n",
    "    R_cylinders = r_center + d_eff/2\n",
    "\n",
    "    # 4. Add carousel thickness\n",
    "    R_total = R_cylinders + t\n",
    "\n",
    "    # 5. Required fuselage diameter\n",
    "    D_required = 2 * R_total\n",
    "\n",
    "    return D_required + 0.03\n",
    "\n",
    "def initial_size_fuselage(hard_constraints, assumed_and_set, iterable_constraints, fuselage_tank_in_wing_root=True):\n",
    "\n",
    "    nose_for_ballast_and_aerodynamics_length = 0.5\n",
    "    ## fuel\n",
    "\n",
    "    # fuel_volume = (iterable_constraints[\"fuel_kg\"] / assumed_and_set[\"fuel_density_kgL\"]) / 1000\n",
    "\n",
    "    # fuselage_cross_section_area = 0.6*0.45 # sized around engine cross section\n",
    "    # fuselage_length_for_fuel = 0.03 + (fuel_volume / fuselage_cross_section_area)\n",
    "    fuselage_length_for_fuel = assumed_and_set[\"fuselage_fuel_tank_length\"]\n",
    "    \n",
    "    # ## payload\n",
    "\n",
    "    internal_payload_length = hard_constraints[\"internal_payload_length\"]\n",
    "\n",
    "    \n",
    "    ## avionics (computers, sensors, camera)\n",
    "\n",
    "    fuselage_length_for_avionics = 0.7 # m \n",
    "\n",
    "    ## wing root requirements\n",
    "\n",
    "    fuselage_length_for_wing_root = 1.2 * iterable_constraints[\"chord_m\"] # this would include the center wing box\n",
    "\n",
    "    ## powerplant\n",
    "\n",
    "    fuselage_length_for_engine = 1 # engine length is 0.7 , added 0.3 for filters and controls\n",
    "\n",
    "    if fuselage_tank_in_wing_root:\n",
    "        total_fuselage_length = nose_for_ballast_and_aerodynamics_length + internal_payload_length + fuselage_length_for_avionics + fuselage_length_for_wing_root + fuselage_length_for_engine\n",
    "    else:\n",
    "        total_fuselage_length = nose_for_ballast_and_aerodynamics_length + fuselage_length_for_fuel + internal_payload_length + fuselage_length_for_avionics + fuselage_length_for_wing_root + fuselage_length_for_engine\n",
    "\n",
    "    return total_fuselage_length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "ff5db026",
   "metadata": {},
   "outputs": [],
   "source": [
    "def refine_design_from_iterable_constraints(hard_constraints, assumed_and_set, weights_dict_kg_no_fuel, iterable_constraints, target_error=0.02, max_iterations=10):\n",
    "    # populate constants and constraints\n",
    "    current_values = iterable_constraints.copy()\n",
    "\n",
    "    prev_values = current_values.copy()\n",
    "\n",
    "    for i in range(max_iterations):\n",
    "\n",
    "        ## cruise iterations\n",
    "\n",
    "        # print(f\"[Iter {i+1}] \" + \" | \".join([f\"{k}: {v:.4f}\" if isinstance(v, float) else f\"{k}: {v}\" for k, v in current_values.items()]))\n",
    "        \n",
    "        h_tail_te_position = current_values[\"tail_arm_m\"] + current_values[\"cruiseout_cg_from_nose_m\"] + 0.75*current_values[\"h_tail_chord_m\"]\n",
    "        # print(current_values[\"fuselage_body_length_m\"], h_tail_te_position)\n",
    "        \n",
    "        cruiseout_v_ms = kmh_to_ms(current_values[\"cruiseout_speed_kmh\"])\n",
    "        rho = get_air_density(hard_constraints[\"cruise_altitude_m\"])\n",
    "        current_values[\"wing_area_m2\"] = calc_required_wing_area(current_values[\"mtow\"], current_values[\"cruiseout_cl\"], rho, cruiseout_v_ms)\n",
    "        \n",
    "        ## cruise out calculations\n",
    "        # Aerodynamics \n",
    "        cruiseout_mtow = current_values[\"mtow\"]\n",
    "        current_values[\"cruiseout_cl\"] = calc_cl_cruise(cruiseout_mtow, current_values[\"cruiseout_speed_kmh\"], current_values[\"wing_area_m2\"], hard_constraints[\"cruise_altitude_m\"])\n",
    "        current_values[\"cruiseout_angle_of_attack_deg\"] = get_row_for_cl(airfoil_coeffs_vs_alpha, current_values[\"cruiseout_cl\"])[\"alpha\"]\n",
    "        current_values[\"cruiseout_cd\"] = calc_cd_total(airfoil_coeffs_vs_alpha[\"CD\"].min(), current_values[\"cruiseout_cl\"], assumed_and_set[\"aspect_ratio\"])\n",
    "        current_values[\"cruiseout_lift_to_drag\"] = current_values[\"cruiseout_cl\"] / current_values[\"cruiseout_cd\"]\n",
    "        cruiseout_drag_n = 0.5 * rho * cruiseout_v_ms**2 * current_values[\"wing_area_m2\"] * current_values[\"cruiseout_cd\"]\n",
    "        cruiseout_power_kw = cruiseout_drag_n * cruiseout_v_ms / propeller_specs[\"efficiency\"][\"cruise\"] / engine_specs[\"gear_box_efficiency\"] / 1000  # kW\n",
    "        current_values[\"cruiseout_power_kw\"] = cruiseout_power_kw\n",
    "\n",
    "        # Engine interpolation\n",
    "        cruiseout_sfc_data = estimate_cruise_sfc_from_dicts(engine_power_to_rpm, engine_sfc_to_rpm, cruiseout_power_kw)\n",
    "        current_values[\"cruiseout_sfc\"] = cruiseout_sfc_data[\"sfc_cruise\"]\n",
    "        current_values[\"cruiseout_rpm\"] = cruiseout_sfc_data[\"rpm_cruise\"]\n",
    "        current_values[\"cruiseout_time\"] = hard_constraints[\"target_station_distance_km\"] / current_values[\"cruiseout_speed_kmh\"] # in hours\n",
    "\n",
    "        cruiseout_fuel_requirement = cruiseout_power_kw * current_values[\"cruiseout_time\"] * current_values[\"cruiseout_sfc\"] \n",
    "\n",
    "        ## loiter calculations\n",
    "        # Aerodynamics \n",
    "        loiter_v_ms = kmh_to_ms(current_values[\"loiter_speed_kmh\"])\n",
    "        loiter_mtow = current_values[\"mtow\"] - cruiseout_fuel_requirement\n",
    "        current_values[\"loiter_cl\"] = calc_cl_cruise(loiter_mtow, current_values[\"loiter_speed_kmh\"], current_values[\"wing_area_m2\"], hard_constraints[\"cruise_altitude_m\"])\n",
    "        current_values[\"loiter_angle_of_attack_deg\"] = get_row_for_cl(airfoil_coeffs_vs_alpha, current_values[\"loiter_cl\"])[\"alpha\"]\n",
    "        current_values[\"loiter_cd\"] = calc_cd_total(airfoil_coeffs_vs_alpha[\"CD\"].min(), current_values[\"loiter_cl\"], assumed_and_set[\"aspect_ratio\"])\n",
    "        current_values[\"loiter_lift_to_drag\"] = current_values[\"loiter_cl\"] / current_values[\"loiter_cd\"]\n",
    "        loiter_drag_n = 0.5 * rho * loiter_v_ms**2 * current_values[\"wing_area_m2\"] * current_values[\"loiter_cd\"]\n",
    "        loiter_power_kw = loiter_drag_n * loiter_v_ms / propeller_specs[\"efficiency\"][\"cruise\"] / engine_specs[\"gear_box_efficiency\"] / 1000  # kW\n",
    "        current_values[\"loiter_power_kw\"] = loiter_power_kw\n",
    "\n",
    "        # Engine interpolation\n",
    "        loiter_sfc_data = estimate_cruise_sfc_from_dicts(engine_power_to_rpm, engine_sfc_to_rpm, loiter_power_kw)\n",
    "        current_values[\"loiter_sfc\"] = loiter_sfc_data[\"sfc_cruise\"]\n",
    "        current_values[\"loiter_rpm\"] = loiter_sfc_data[\"rpm_cruise\"]\n",
    "\n",
    "        loiter_fuel_requirement = loiter_power_kw * hard_constraints[\"loiter_time\"] * 1.1 * current_values[\"loiter_sfc\"] \n",
    "\n",
    "        estimate_loiter_fuel = loiter_power_kw * hard_constraints[\"loiter_time\"] * 1.1 * current_values[\"cruiseout_sfc\"] ## 1.2 is a multiplier to estimate the increased SFC at the lower RPM during loiter\n",
    "        \n",
    "\n",
    "        ## cruise back calculations\n",
    "        # Aerodynamics \n",
    "        cruiseback_v_ms = kmh_to_ms(current_values[\"cruiseback_speed_kmh\"])\n",
    "        cruiseback_mtow = current_values[\"mtow\"] - cruiseout_fuel_requirement - loiter_fuel_requirement - hard_constraints[\"internal_payload_mass\"] - hard_constraints[\"wing_payload_mass\"]\n",
    "        current_values[\"cruiseback_cl\"] = calc_cl_cruise(cruiseback_mtow, current_values[\"cruiseback_speed_kmh\"], current_values[\"wing_area_m2\"], hard_constraints[\"cruise_altitude_m\"])\n",
    "        current_values[\"cruiseback_angle_of_attack_deg\"] = get_row_for_cl(airfoil_coeffs_vs_alpha, current_values[\"cruiseback_cl\"])[\"alpha\"]\n",
    "        current_values[\"cruiseback_cd\"] = calc_cd_total(airfoil_coeffs_vs_alpha[\"CD\"].min(), current_values[\"cruiseback_cl\"], assumed_and_set[\"aspect_ratio\"])\n",
    "        current_values[\"cruiseback_lift_to_drag\"] = current_values[\"cruiseback_cl\"] / current_values[\"cruiseback_cd\"]\n",
    "        cruiseback_drag_n = 0.5 * rho * cruiseback_v_ms**2 * current_values[\"wing_area_m2\"] * current_values[\"cruiseback_cd\"]\n",
    "        cruiseback_power_kw = cruiseback_drag_n * cruiseback_v_ms / propeller_specs[\"efficiency\"][\"cruise\"] / engine_specs[\"gear_box_efficiency\"] / 1000  # kW\n",
    "        current_values[\"cruiseback_power_kw\"] = cruiseback_power_kw\n",
    "\n",
    "        # Engine interpolation\n",
    "        cruiseback_sfc_data = estimate_cruise_sfc_from_dicts(engine_power_to_rpm, engine_sfc_to_rpm, cruiseback_power_kw)\n",
    "        current_values[\"cruiseback_sfc\"] = cruiseback_sfc_data[\"sfc_cruise\"]\n",
    "        current_values[\"cruiseback_rpm\"] = cruiseback_sfc_data[\"rpm_cruise\"]\n",
    "        current_values[\"cruiseback_time\"] = hard_constraints[\"target_station_distance_km\"] / current_values[\"cruiseback_speed_kmh\"] # in hours\n",
    "\n",
    "        cruiseback_fuel_requirement = cruiseback_power_kw * current_values[\"cruiseback_time\"] * current_values[\"cruiseback_sfc\"] \n",
    "\n",
    "\n",
    "        current_values[\"fuel_kg\"] = cruiseout_fuel_requirement + estimate_loiter_fuel + cruiseback_fuel_requirement\n",
    "\n",
    "        current_values[\"mtow\"]  = sum(weights_dict_kg_no_fuel.values()) + current_values[\"fuel_kg\"]\n",
    "\n",
    "        # Wing geometry - stays fixed for following flight stages\n",
    "        current_values[\"wing_area_m2\"] = calc_required_wing_area(current_values[\"mtow\"], current_values[\"cruiseout_cl\"], rho, cruiseout_v_ms)\n",
    "        current_values[\"wing_span_m\"] = np.sqrt(current_values[\"wing_area_m2\"] * assumed_and_set[\"aspect_ratio\"])\n",
    "        current_values[\"chord_m\"] = current_values[\"wing_area_m2\"] / current_values[\"wing_span_m\"]\n",
    "        current_values[\"wing_loading_pa\"] = current_values[\"mtow\"] * g / current_values[\"wing_area_m2\"] \n",
    "\n",
    "        current_values[\"tail_arm_m\"] = assumed_and_set[\"horizontal_tail_arm_mac_coeff\"] * current_values[\"chord_m\"]\n",
    "\n",
    "        # --- Horizontal Tail Area (S_h) ---\n",
    "        current_values[\"horizontal_tail_area_m2\"] = assumed_and_set[\"horizontal_tail_volume_coefficient\"] *  (current_values[\"wing_area_m2\"] * current_values[\"chord_m\"]) / current_values[\"tail_arm_m\"]\n",
    "        \n",
    "\n",
    "        current_values[\"h_tail_span_m\"], current_values[\"h_tail_chord_m\"] = tail_geometry(current_values[\"horizontal_tail_area_m2\"], assumed_and_set[\"AR_horizontal\"])\n",
    "        \n",
    "        # --- Vertical Tail Area (S_v) ---\n",
    "        current_values[\"vertical_tail_area_m2\"] = assumed_and_set[\"vertical_tail_volume_coefficient\"] *(current_values[\"wing_area_m2\"] * current_values[\"wing_span_m\"]) /current_values[\"tail_arm_m\"]\n",
    "        \n",
    "\n",
    "        current_values[\"v_tail_span_m\"], current_values[\"v_tail_chord_m\"] = tail_geometry(current_values[\"vertical_tail_area_m2\"], assumed_and_set[\"AR_vertical\"])\n",
    "        # current_values[\"v_tail_span_m\"], current_values[\"v_tail_chord_m\"] = tail_geometry(current_values[\"vertical_tail_area_m2\"], 2.0)  # Assuming AR of 2.0 for vertical tail\n",
    "\n",
    "\n",
    "        # --- Fuselage Geometry ---\n",
    "        \n",
    "\n",
    "        current_values[\"fuselage_body_length_m\"] = initial_size_fuselage(hard_constraints, assumed_and_set, current_values, False)\n",
    "        # current_values[\"fuselage_body_length_m\"] = h_tail_te_position\n",
    "\n",
    "        # current_values[\"fuselage_tail_arm_extension_m\"] = max(0, h_tail_te_position - current_values[\"fuselage_body_length_m\"])\n",
    "\n",
    "        # if current_values[\"fuselage_tail_arm_extension_m\"] == 0:\n",
    "        wing_le_position_m = assumed_and_set[\"wing_le_position_fuselage_length_coeff\"] * current_values[\"fuselage_body_length_m\"]\n",
    "        current_values[\"wing_le_position_m\"] = wing_le_position_m\n",
    "        \n",
    "\n",
    "        # --- range, endurance, and fuel requirements ---\n",
    "\n",
    "        cruise_fuel = cruiseout_fuel_requirement\n",
    "        loiter_fuel = loiter_fuel_requirement\n",
    "\n",
    "        cb = current_values[\"loiter_sfc\"]\n",
    "        rho = get_air_density(hard_constraints[\"cruise_altitude_m\"])\n",
    "        w_0 = (current_values[\"mtow\"] - cruise_fuel ) * g\n",
    "        w_f = (current_values[\"mtow\"] - cruise_fuel - loiter_fuel) * g\n",
    "\n",
    "        Breguet_endurance = current_values[\"loiter_lift_to_drag\"] * (1/cb) * np.log(w_0/w_f)\n",
    "\n",
    "        current_values[\"calculated_loiter_time\"] = Breguet_endurance  # in hours\n",
    "\n",
    "        ## fuel tank calculations\n",
    "        current_values[\"required_fuel_volume_m3\"] = current_values[\"fuel_kg\"] / assumed_and_set[\"fuel_density_kgL\"] / 1000\n",
    "        current_values[\"max_theoretical_range\"] = current_values[\"cruiseout_speed_kmh\"]  * (current_values[\"fuel_kg\"]/2) / (current_values[\"cruiseout_power_kw\"] * current_values[\"cruiseout_sfc\"])\n",
    "\n",
    "        fuselage_cross_section_area = (current_values[\"fuselage_body_width_m\"] - 2*sandwich_specs[\"fuselage\"][\"total_thickness_m\"] - 0.02) *( current_values[\"fuselage_body_height_m\"] - 2*sandwich_specs[\"fuselage\"][\"total_thickness_m\"] - 0.02)\n",
    "        fuselage_fuel_tank = assumed_and_set[\"fuselage_fuel_tank_length\"] * fuselage_cross_section_area #cross_section_area_fuselage_fuel_tank(iterable_constraints[\"fuselage_diameter_m\"], 0.8)\n",
    "        wing_fuel_tank = wing_fuel_tank_volume(\"naca2412_coords.dat\", current_values, 0.25, 0.65)\n",
    "        current_values[\"space_available_for_fuel_m3\"] = fuselage_fuel_tank + wing_fuel_tank\n",
    "        \n",
    "        if current_values[\"required_fuel_volume_m3\"] < fuselage_fuel_tank:\n",
    "            fuselage_fuel = current_values[\"fuel_kg\"]\n",
    "        else:\n",
    "            fuselage_fuel = fuselage_fuel_tank * 1000 * assumed_and_set[\"fuel_density_kgL\"]  \n",
    "\n",
    "        wing_fuel = current_values[\"fuel_kg\"] - fuselage_fuel\n",
    "\n",
    "        # airframe mass estimation\n",
    "\n",
    "        fuselage_mass = get_fuselage_mass(current_values[\"fuselage_body_length_m\"], current_values[\"fuselage_body_width_m\"], \n",
    "                                          current_values[\"fuselage_body_height_m\"], assumed_and_set) * assumed_and_set[\"fuselage_internal_supports_mass_multiplier\"]\n",
    "        weights_dict_kg_no_fuel[\"fuselage\"] = fuselage_mass\n",
    "\n",
    "        wing_cross_section_perimeter_length = airfoil_perimeter_length(x, y, current_values[\"chord_m\"])\n",
    "        wing_mass = get_wing_or_tail_mass(current_values[\"wing_span_m\"], wing_cross_section_perimeter_length,\"wing\", assumed_and_set) * assumed_and_set[\"wing_internal_supports_mass_multiplier\"]\n",
    "        weights_dict_kg_no_fuel[\"wing\"] = wing_mass\n",
    "        \n",
    "        horizontal_tail_perimeter = airfoil_perimeter_length(x, y, current_values[\"h_tail_chord_m\"])\n",
    "        horizontal_tail_mass = get_wing_or_tail_mass(current_values[\"h_tail_span_m\"], horizontal_tail_perimeter,\"tail\", assumed_and_set) * assumed_and_set[\"tail_internal_supports_mass_multiplier\"]\n",
    "\n",
    "        vertical_tail_perimeter = airfoil_perimeter_length(x, y, current_values[\"v_tail_chord_m\"])\n",
    "        vertical_tail_mass = get_wing_or_tail_mass(current_values[\"v_tail_span_m\"], vertical_tail_perimeter,\"tail\", assumed_and_set) * assumed_and_set[\"tail_internal_supports_mass_multiplier\"]\n",
    "        \n",
    "        weights_dict_kg_no_fuel[\"tails\"] = horizontal_tail_mass + vertical_tail_mass\n",
    "        \n",
    "        #cg position estimation\n",
    "        weights_for_cg = weights_dict_kg_no_fuel.copy()\n",
    "        weights_for_cg[\"fuselage_fuel\"] = fuselage_fuel\n",
    "        weights_for_cg[\"wing_fuel\"] = wing_fuel\n",
    "\n",
    "\n",
    "        #post payload drop\n",
    "        # post_weights_for_cg = weights_for_cg.copy()\n",
    "        # post_weights_for_cg[\"payload\"] = 0.0\n",
    "        # post_weights_for_cg[\"fuel\"] = current_values[\"fuel_kg\"] - cruise_fuel - loiter_fuel\n",
    "\n",
    "        component_positions_m = estimate_component_positions(\n",
    "            fuselage_length=current_values[\"fuselage_body_length_m\"],\n",
    "            wing_le_position=wing_le_position_m,\n",
    "            chord=current_values[\"chord_m\"],\n",
    "            tail_arm=current_values[\"tail_arm_m\"],\n",
    "            internal_payload_length=hard_constraints[\"internal_payload_length\"],\n",
    "            fuselage_fuel_tank_length=assumed_and_set[\"fuselage_fuel_tank_length\"],\n",
    "            cg_estimate=current_values[\"cruiseout_cg_from_nose_m\"],\n",
    "        )\n",
    "\n",
    "        current_values[\"cruiseout_cg_from_nose_m\"] = calculate_cg(weights_for_cg, component_positions_m)\n",
    "\n",
    "        cruise_out_stability_dict = stability_analysis(current_values[\"chord_m\"], current_values[\"cruiseout_cg_from_nose_m\"], \n",
    "                                                       assumed_and_set[\"horizontal_tail_volume_coefficient\"], current_values[\"wing_le_position_m\"])\n",
    "        \n",
    "        current_values[\"neutral_point_m\"] = cruise_out_stability_dict[\"neutral_point_m\"]\n",
    "        current_values[\"cruiseout_static_margin\"] = cruise_out_stability_dict[\"static_margin\"]\n",
    "\n",
    "        # print(f\"Static Margin: {current_values['static_margin']:.4f} | Static Margin Post Drop: {post_drop_vals['static_margin']:.4f}\")\n",
    "        eta_h = calculate_eta_h(current_values[\"wing_span_m\"], current_values[\"tail_arm_m\"])\n",
    "        \n",
    "        trim_dict = cruise_trim_analysis(current_values[\"neutral_point_m\"], current_values[\"cruiseout_cg_from_nose_m\"], \n",
    "                                              current_values[\"cruiseout_cl\"], current_values[\"tail_arm_m\"], eta_h)\n",
    "        \n",
    "        current_values[\"cruiseout_cl_tail_required\"] = trim_dict[\"cl_tail_required\"]\n",
    "        current_values[\"cruiseout_delta_elevator_deg\"] = trim_dict[\"delta_elevator_deg\"]\n",
    "        \n",
    "        \n",
    "        relative_errors = {\n",
    "            k: abs(current_values[k] - prev_values[k]) / max(abs(current_values[k]), 1e-6)\n",
    "            for k in current_values\n",
    "        }\n",
    "\n",
    "        \n",
    "        for iter_key in prev_values:\n",
    "            prev_values[iter_key] = current_values[iter_key]  # ← updates global dict\n",
    "\n",
    "        if all(err < target_error for err in relative_errors.values()):\n",
    "\n",
    "            for iter_key in iterable_constraints:\n",
    "                iterable_constraints[iter_key] = current_values[iter_key]  # ← updates global dict\n",
    "                \n",
    "            if current_values[\"required_fuel_volume_m3\"] > current_values[\"space_available_for_fuel_m3\"]:\n",
    "                print(f\"❌ Design failed: Required fuel volume {current_values['required_fuel_volume_m3']:.5f} m³ exceeds available space {current_values['space_available_for_fuel_m3']:.5f} m³.\")\n",
    "                return current_values\n",
    "            \n",
    "            \n",
    "            print(f\"Converged in {i+1} iterations.\")\n",
    "            return current_values\n",
    "\n",
    "\n",
    "\n",
    "    \n",
    "    return current_values\n",
    "    # raise ValueError(\"Design iteration did not converge.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "f5f630d6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Converged in 12 iterations.\n"
     ]
    }
   ],
   "source": [
    "\n",
    "assumed_and_set = {\n",
    "    # Mission requirements\n",
    "    \"rolling_resistance_coefficient\": 0.04, # dimensionless   \n",
    "    \"target_drop_altitude_m\": 2500,\n",
    "    \"sea_level_air_density\": get_air_density(0),\n",
    "    \"horizontal_tail_volume_coefficient\": 0.75, # dimensionless\n",
    "    \"vertical_tail_volume_coefficient\": 0.03, # dimensionless\n",
    "    \"horizontal_tail_arm_mac_coeff\": 3, # dimensionless\n",
    "    # \"fuselage_length_mac_coeff\": 5, # dimensionless\n",
    "    \"wing_le_position_fuselage_length_coeff\": 0.5, # dimensionless\n",
    "    # Configuration\n",
    "    \"fuel_density_kgL\": 0.74,\n",
    "    \"gfrp_thickness_m\": 0.0015, # meters\n",
    "    \"gfrp_density_kgm3\": 2150, # kg/m^3\n",
    "    \"core_density_kgm3\": 60,\n",
    "    \"fuselage_fuel_tank_length\": 0.55, #meters\n",
    "    \"fuselage_internal_supports_mass_multiplier\": 1.3,\n",
    "    \"wing_internal_supports_mass_multiplier\": 1.3,\n",
    "    \"tail_internal_supports_mass_multiplier\": 1.1,\n",
    "    \"aspect_ratio\": 14  , # starting assumption\n",
    "    \"AR_horizontal\": 4.0,                # aspect ratio of horizontal tail\n",
    "    \"AR_vertical\": 2.0,                  # aspect ratio of vertical tail\n",
    "    # \"cl_alpha\" : 8.44, # cl / angle of attack slope in (rad). taken from airfoil data\n",
    "    \"loiter_drag_multiplier\": 1.05, ## assumes 5% extra drag due to turns, lower speed, and loss of energy\n",
    "}\n",
    "\n",
    "hard_constraints = {\n",
    "    \"wing_payload_mass\" : 100, # kg\n",
    "    \"internal_payload_mass\": 100, #kg\n",
    "    \"internal_payload_length\": 1.3, # meter\n",
    "    \"target_station_distance_km\": 100,\n",
    "    \"loiter_time\": 1, # hours\n",
    "    \"takeoff_distance_max_m\": 50, # dirt road\n",
    "    \"climb_time_min\": 13, # minutes\n",
    "    \"cruise_altitude_m\": 2500,  \n",
    "}\n",
    "\n",
    "weights_dict_kg_no_fuel = {\n",
    "    \"fuselage\": 40,\n",
    "    \"wing\": 230,\n",
    "    \"tails\": 10,\n",
    "    \"internal_payload\": hard_constraints[\"internal_payload_mass\"],\n",
    "    \"wing_payload\": hard_constraints[\"wing_payload_mass\"],\n",
    "    \"engine\": engine_specs[\"dry_weight_kg\"],\n",
    "    \"propeller\": propeller_specs[\"weight_kg\"],\n",
    "    \"avionics\": 40,\n",
    "    \"landing_gear\": 20,\n",
    "    \"misc\": 10,\n",
    "}\n",
    "\n",
    "iterable_constraints = {\n",
    "\n",
    "    ## structural design variables\n",
    "    #################################\n",
    "    \"wing_area_m2\": 16, # starting assumption\n",
    "    \"wing_loading_pa\": 500,\n",
    "    \"wing_span_m\": 16, # meters\n",
    "    \"chord_m\": 1,  # meters\n",
    "    \"neutral_point_m\": 2.5, # meters\n",
    "    \"wing_le_position_m\": 1.2824, # meters — same as before\n",
    "    \n",
    "    ## fuselage square section \"body\"\n",
    "    \"fuselage_body_length_m\": 4.9,     # meters — same as before\n",
    "    \"fuselage_body_width_m\": 0.62,     # meters — same as before\n",
    "    \"fuselage_body_height_m\": 0.45,     # meters — same as before\n",
    "    \"fuselage_tail_arm_extension_m\": 0, # meter\n",
    "    ## fuselage nose section\n",
    "\n",
    "\n",
    "\n",
    "    \"space_available_for_fuel_m3\": 0.05, # available space for fuel (m^3)\n",
    "\n",
    "    \"tail_arm_m\": 2.3659,  # meters\n",
    "\n",
    "    \"horizontal_tail_area_m2\": 0.4351,    # square meters\n",
    "    \"h_tail_chord_m\": 0.2579,               # meters\n",
    "    \"h_tail_span_m\": 1.0,                  # meters\n",
    "\n",
    "    \"vertical_tail_area_m2\": 0.1741,      # square meters\n",
    "    \"v_tail_chord_m\": 0.1741,              # meters\n",
    "    \"v_tail_span_m\": 1.0,                  # meters\n",
    "\n",
    "    ## performance design variables\n",
    "    ###################################\n",
    "    \"required_fuel_volume_m3\": 0.02, # required fuel volume (m^3)\n",
    "    \"max_theoretical_range\": 1.25*hard_constraints[\"target_station_distance_km\"], # maximum theoretical range (km)\n",
    "    \"stall_speed_kmh\": 55, # stall speed (km/h)\n",
    "    \"fuel_kg\": 30, # kg starting assumption\n",
    "    \"mtow\": sum(weights_dict_kg_no_fuel.values()) + 30, # starting assumption\n",
    "\n",
    "\n",
    "    ## cruise out variables\n",
    "    ##############################\n",
    "    \"cruiseout_speed_kmh\": 130, #km/h\n",
    "    \"cruiseout_wing_loading_pa\": 180, # starting assumption\n",
    "    \"cruiseout_cg_from_nose_m\": 2.5,                # meters\n",
    "    \"cruiseout_cl\": 0.8, # lift coefficient at cruise\n",
    "    \"cruiseout_cd\" : 0.05, # drag coefficient at cruise\n",
    "    \"cruiseout_lift_to_drag\": 16, # lift-to-drag ratio at cruise\n",
    "    \"cruiseout_sfc\": 0.5, # specific fuel consumption at cruise (kg/kWh)\n",
    "    \"cruiseout_rpm\": 5000, # engine RPM at cruise\n",
    "    \"cruiseout_power_kw\": 8, # power required at cruise (kW)\n",
    "    \"cruiseout_static_margin\": 0.1, # static margin (dimensionless)\n",
    "    \"cruiseout_delta_elevator_deg\": 5, # elevator deflection angle (degrees)\n",
    "    \"cruiseout_cl_tail_required\": -0.04, # required lift coefficient for tail\n",
    "    \"cruiseout_angle_of_attack_deg\": 5, # needs to be converted to radians for calculations\n",
    "    \n",
    "    \"cruiseout_time\": 3, # cruise time (hours)\n",
    "\n",
    "    ## loiter variables\n",
    "    ###############################\n",
    "    \"loiter_speed_kmh\": 100, #km/h\n",
    "    \"loiter_wing_loading_pa\": 180, # starting assumption\n",
    "    \"loiter_cg_from_nose_m\": 2.5,                # meters\n",
    "    \"loiter_cl\": 0.8, # lift coefficient at loiter\n",
    "    \"loiter_cd\" : 0.05, # drag coefficient at loiter\n",
    "    \"loiter_lift_to_drag\": 16, # lift-to-drag ratio at loiter\n",
    "    \"loiter_sfc\": 0.5, # specific fuel consumption at loiter (kg/kWh)\n",
    "    \"loiter_rpm\": 5000, # engine RPM at loiter\n",
    "    \"loiter_power_kw\": 8, # power required at loiter (kW)\n",
    "    \"loiter_static_margin\": 0.1, # static margin (dimensionless)\n",
    "    \"loiter_delta_elevator_deg\": 5, # elevator deflection angle (degrees)\n",
    "    \"loiter_cl_tail_required\": -0.04, # required lift coefficient for tail\n",
    "    \"loiter_angle_of_attack_deg\": 5, # needs to be converted to radians for calculations\n",
    "    \"calculated_loiter_time\": hard_constraints[\"loiter_time\"],\n",
    "    \n",
    "    ## cruise back variables\n",
    "    ###############################\n",
    "\n",
    "    \"cruiseback_speed_kmh\": 130,\n",
    "    \"cruiseback_wing_loading_pa\": 180, # starting assumption\n",
    "    \"cruiseback_cg_from_nose_m\": 2.5,                # meters\n",
    "    \"cruiseback_cl\": 0.8, # lift coefficient at cruiseback\n",
    "    \"cruiseback_cd\" : 0.05, # drag coefficient at cruiseback\n",
    "    \"cruiseback_lift_to_drag\": 16, # lift-to-drag ratio at cruiseback\n",
    "    \"cruiseback_sfc\": 0.5, # specific fuel consumption at cruiseback (kg/kWh)\n",
    "    \"cruiseback_rpm\": 5000, # engine RPM at cruiseback\n",
    "    \"cruiseback_power_kw\": 8, # power required at cruiseback (kW)\n",
    "    \"cruiseback_static_margin\": 0.1, # static margin (dimensionless)\n",
    "    \"cruiseback_delta_elevator_deg\": 5, # elevator deflection angle (degrees)\n",
    "    \"cruiseback_cl_tail_required\": -0.04, # required lift coefficient for tail\n",
    "    \"cruiseback_angle_of_attack_deg\": 5, # needs to be converted to radians for calculations\n",
    "\n",
    "    \"cruiseback_time\": 3, # cruiseback time (hours)\n",
    "    \n",
    "    \n",
    "    \n",
    "}\n",
    "\n",
    "predrop = refine_design_from_iterable_constraints(\n",
    "    hard_constraints, \n",
    "    assumed_and_set, \n",
    "    weights_dict_kg_no_fuel,\n",
    "    iterable_constraints,\n",
    "    target_error=0.0005,\n",
    "    max_iterations=60\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "d30246c8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Pre Drop Values\n",
      "===================================\n",
      "Maximum Takeoff Weight:  796.4589178040898\n",
      "Fuel Weight:  14.890434670240598\n",
      "neutral_point_m:  3.716910605548878\n",
      "cg_from_nose_m:  3.423451833609543\n",
      "static_margin:  0.2775170470372533\n",
      "cl_tail_required:  -0.0740045458766009\n",
      "wing_le_position_m:  2.659466477080829\n",
      "payload cg:  3.1881885413148536\n",
      "\n"
     ]
    }
   ],
   "source": [
    "print(\"Pre Drop Values\")\n",
    "print(\"===================================\")\n",
    "\n",
    "print(\"Maximum Takeoff Weight: \", predrop[\"mtow\"])\n",
    "print(\"Fuel Weight: \", predrop[\"fuel_kg\"])\n",
    "print(\"neutral_point_m: \",predrop[\"neutral_point_m\"])\n",
    "print(\"cg_from_nose_m: \",predrop[\"cruiseout_cg_from_nose_m\"])\n",
    "print(\"static_margin: \",predrop[\"cruiseout_static_margin\"])\n",
    "# print(\"delta_elevator_deg: \",predrop[\"cruiseout_delta_elevator_deg\"])\n",
    "print(\"cl_tail_required: \",predrop[\"cruiseout_cl_tail_required\"])\n",
    "print(\"wing_le_position_m: \",predrop[\"wing_le_position_m\"])\n",
    "print(\"payload cg: \",predrop[\"wing_le_position_m\"] + iterable_constraints[\"chord_m\"]*0.5)\n",
    "print()\n",
    "# print(\"Post Drop Values\")\n",
    "# print(\"===================================\")\n",
    "# print(\"neutral_point_m: \",postdrop[\"neutral_point_m\"])\n",
    "# print(\"cg_from_nose_m: \",postdrop[\"cg_from_nose_m\"])\n",
    "# print(\"static_margin: \",postdrop[\"static_margin\"])\n",
    "# print(\"delta_elevator_deg: \",postdrop[\"delta_elevator_deg\"])\n",
    "# print(\"cl_tail_required: \",postdrop[\"cl_tail_required\"])\n",
    "# print(\"wing_le_position_m: \",postdrop[\"wing_le_position_m\"])\n",
    "\n",
    "\n",
    "# print()\n",
    "# print()\n",
    "# print(\"horizontal_tail_volume_coefficient: \",assumed_and_set[\"horizontal_tail_volume_coefficient\"])\n",
    "# print(\"vertical_tail_volume_coefficient: \",assumed_and_set[\"vertical_tail_volume_coefficient\"])\n",
    "# print(\"wing_le_position_fuselage_length_coeff: \",assumed_and_set[\"wing_le_position_fuselage_length_coeff\"])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 185,
   "id": "453b5ac3",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-2.8751174396042636"
      ]
     },
     "execution_count": 185,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "get_row_for_cl(airfoil_coeffs_vs_alpha, predrop[\"cruiseout_cl_tail_required\"])[\"alpha\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "2d2f8bf3",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'wing_area_m2': 15.65463318764173,\n",
       " 'wing_loading_pa': 499.102207634361,\n",
       " 'wing_span_m': 14.804217798552688,\n",
       " 'chord_m': 1.0574441284680491,\n",
       " 'neutral_point_m': 3.716910605548878,\n",
       " 'wing_le_position_m': 2.659466477080829,\n",
       " 'fuselage_body_length_m': 5.318932954161658,\n",
       " 'fuselage_body_width_m': 0.62,\n",
       " 'fuselage_body_height_m': 0.45,\n",
       " 'fuselage_tail_arm_extension_m': 0,\n",
       " 'space_available_for_fuel_m3': 0.23643150712017674,\n",
       " 'tail_arm_m': 3.1723323854041476,\n",
       " 'horizontal_tail_area_m2': 3.913658296910432,\n",
       " 'h_tail_chord_m': 0.9891484085958021,\n",
       " 'h_tail_span_m': 3.956593634383209,\n",
       " 'vertical_tail_area_m2': 2.1916486462698423,\n",
       " 'v_tail_chord_m': 1.046816279551919,\n",
       " 'v_tail_span_m': 2.093632559103838,\n",
       " 'required_fuel_volume_m3': 0.020122209013838644,\n",
       " 'max_theoretical_range': 162.05029223847646,\n",
       " 'stall_speed_kmh': 55,\n",
       " 'fuel_kg': 14.890434670240598,\n",
       " 'mtow': 796.4589178040898,\n",
       " 'cruiseout_speed_kmh': 130,\n",
       " 'cruiseout_wing_loading_pa': 180,\n",
       " 'cruiseout_cg_from_nose_m': 3.423451833609543,\n",
       " 'cruiseout_cl': 0.8000000000000003,\n",
       " 'cruiseout_cd': 0.023679136353359484,\n",
       " 'cruiseout_lift_to_drag': 33.785015976163336,\n",
       " 'cruiseout_sfc': 0.5436221298254789,\n",
       " 'cruiseout_rpm': 1969.8155847876758,\n",
       " 'cruiseout_power_kw': 10.986864941390486,\n",
       " 'cruiseout_static_margin': 0.2775170470372533,\n",
       " 'cruiseout_delta_elevator_deg': -48.32995604306424,\n",
       " 'cruiseout_cl_tail_required': -0.0740045458766009,\n",
       " 'cruiseout_angle_of_attack_deg': 4.900000000000003,\n",
       " 'cruiseout_time': 0.7692307692307693,\n",
       " 'loiter_speed_kmh': 100,\n",
       " 'loiter_wing_loading_pa': 180,\n",
       " 'loiter_cg_from_nose_m': 2.5,\n",
       " 'loiter_cl': 1.3441998562752915,\n",
       " 'loiter_cd': 0.05684228747368736,\n",
       " 'loiter_lift_to_drag': 23.64788462986346,\n",
       " 'loiter_sfc': 0.5364377813448127,\n",
       " 'loiter_rpm': 2029.6851554598938,\n",
       " 'loiter_power_kw': 12.004647642818192,\n",
       " 'loiter_static_margin': 0.1,\n",
       " 'loiter_delta_elevator_deg': 5,\n",
       " 'loiter_cl_tail_required': -0.04,\n",
       " 'loiter_angle_of_attack_deg': 10.969442448267937,\n",
       " 'calculated_loiter_time': 0.39612596174692116,\n",
       " 'cruiseback_speed_kmh': 130,\n",
       " 'cruiseback_wing_loading_pa': 180,\n",
       " 'cruiseback_cg_from_nose_m': 2.5,\n",
       " 'cruiseback_cl': 0.5873505399340426,\n",
       " 'cruiseback_cd': 0.015294531570459218,\n",
       " 'cruiseback_lift_to_drag': 38.40264981168086,\n",
       " 'cruiseback_sfc': 0.5710835408664194,\n",
       " 'cruiseback_rpm': 1740.9704927798373,\n",
       " 'cruiseback_power_kw': 7.096498377257235,\n",
       " 'cruiseback_static_margin': 0.1,\n",
       " 'cruiseback_delta_elevator_deg': 5,\n",
       " 'cruiseback_cl_tail_required': -0.04,\n",
       " 'cruiseback_angle_of_attack_deg': 2.968957777346684,\n",
       " 'cruiseback_time': 0.7692307692307693}"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "predrop"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 186,
   "id": "bbd5ea7f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Estimated Takeoff Distance (with Drag & Resistance): 179.63 meters\n"
     ]
    }
   ],
   "source": [
    "def calculate_takeoff_distance_with_drag(\n",
    "    mtow_kg,\n",
    "    wing_area_m2,\n",
    "    cl_max_takeoff,\n",
    "    thrust_avg_n,\n",
    "    cd_takeoff=0.05,\n",
    "    rolling_resistance_coeff=0.04,  # Dirt road typical value\n",
    "    rho=1.225,  # Sea level air density\n",
    "    g=9.81\n",
    "):\n",
    "    W = mtow_kg * g  # Weight in Newtons\n",
    "    wing_loading_pa = W / wing_area_m2\n",
    "\n",
    "    # Stall and Takeoff Speed\n",
    "    v_stall_ms = np.sqrt((2 * W) / (rho * wing_area_m2 * cl_max_takeoff))\n",
    "    v_takeoff_ms = 1.2 * v_stall_ms  # 20% margin above stall speed\n",
    "\n",
    "    # Assume average speed during takeoff roll is half the takeoff speed\n",
    "    v_avg_ms = v_takeoff_ms / 2\n",
    "\n",
    "    # Calculate average lift during ground roll\n",
    "    lift_avg_n = 0.5 * rho * v_avg_ms**2 * wing_area_m2 * cl_max_takeoff\n",
    "\n",
    "    # Calculate average drag during ground roll\n",
    "    drag_avg_n = 0.5 * rho * v_avg_ms**2 * wing_area_m2 * cd_takeoff\n",
    "\n",
    "    # Net accelerating force\n",
    "    net_force_n = thrust_avg_n - drag_avg_n - rolling_resistance_coeff * (W - lift_avg_n)\n",
    "\n",
    "    if net_force_n <= 0:\n",
    "        return np.inf  # Cannot take off with current configuration\n",
    "\n",
    "    # Final Takeoff Distance\n",
    "    takeoff_distance_m = (v_takeoff_ms ** 2) / (2 * g * (net_force_n / W))\n",
    "\n",
    "    return takeoff_distance_m\n",
    "\n",
    "# Example Usage\n",
    "mtow_kg = iterable_constraints[\"mtow\"]\n",
    "wing_area_m2 = iterable_constraints[\"wing_area_m2\"]\n",
    "cl_max_takeoff = 1.8\n",
    "cd_takeoff = 0.05\n",
    "prop_efficiency = 0.8\n",
    "rolling_resistance_coeff = 0.04\n",
    "max_power_kw = 55\n",
    "rho=1.225\n",
    "\n",
    "# Calculate available thrust at takeoff speed\n",
    "power_available_w = max_power_kw * 1000 * prop_efficiency\n",
    "v_takeoff_ms = 1.2 * np.sqrt((2 * mtow_kg * g) / (rho * wing_area_m2 * cl_max_takeoff))\n",
    "thrust_avg_n = power_available_w / v_takeoff_ms\n",
    "\n",
    "# Calculate Takeoff Distance with Drag and Rolling Resistance\n",
    "takeoff_distance_m = calculate_takeoff_distance_with_drag(\n",
    "    mtow_kg, wing_area_m2, cl_max_takeoff, thrust_avg_n,\n",
    "    cd_takeoff, rolling_resistance_coeff\n",
    ")\n",
    "\n",
    "print(f\"Estimated Takeoff Distance (with Drag & Resistance): {takeoff_distance_m:.2f} meters\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "aefcad76",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.patches as patches\n",
    "\n",
    "def plot_uav_top_view(fuselage_length, fuselage_width,\n",
    "                      wing_span, wing_chord, wing_le_position,\n",
    "                      tail_span, tail_chord, tail_le_position,\n",
    "                      components=None, cg_position=None, np_position=None):\n",
    "    \"\"\"\n",
    "    Plot the top view of a UAV with rectangular fuselage, wing, tail, CG, NP, and other components.\n",
    "\n",
    "    Parameters:\n",
    "        fuselage_length (float)\n",
    "        fuselage_width (float)\n",
    "        wing_span (float)\n",
    "        wing_chord (float)\n",
    "        wing_le_position (float)\n",
    "        tail_span (float)\n",
    "        tail_chord (float)\n",
    "        tail_le_position (float)\n",
    "        components (dict): Optional dict of {label: x_position}\n",
    "        cg_position (float): X location of CG\n",
    "        np_position (float): X location of Neutral Point\n",
    "    \"\"\"\n",
    "    fig, ax = plt.subplots(figsize=(30, 10))\n",
    "    \n",
    "    # Draw fuselage\n",
    "    fuselage = patches.Rectangle((0, -fuselage_width / 2),\n",
    "                                 fuselage_length,\n",
    "                                 fuselage_width,\n",
    "                                 edgecolor='black',\n",
    "                                 facecolor='lightgray',\n",
    "                                 label='Fuselage')\n",
    "    ax.add_patch(fuselage)\n",
    "\n",
    "    # Draw wing\n",
    "    wing = patches.Rectangle((wing_le_position, -wing_span / 2),\n",
    "                             wing_chord,\n",
    "                             wing_span,\n",
    "                             edgecolor='blue',\n",
    "                             facecolor='lightblue',\n",
    "                             label='Wing')\n",
    "    ax.add_patch(wing)\n",
    "\n",
    "    # Draw tail\n",
    "    tail = patches.Rectangle((tail_le_position, -tail_span / 2),\n",
    "                             tail_chord,\n",
    "                             tail_span,\n",
    "                             edgecolor='darkred',\n",
    "                             facecolor='salmon',\n",
    "                             label='Tail')\n",
    "\n",
    "    ax.add_patch(tail)\n",
    "\n",
    "    # Draw propeller\n",
    "    propeller = patches.Rectangle((fuselage_length, -propeller_specs[\"diameter_m\"] / 2),\n",
    "                             0.1,\n",
    "                             propeller_specs[\"diameter_m\"],\n",
    "                             edgecolor='darkred',\n",
    "                             facecolor='red',\n",
    "                             label='Prop')\n",
    "    \n",
    "    ax.add_patch(propeller)\n",
    "\n",
    "    # Plot CG\n",
    "    if cg_position is not None:\n",
    "        ax.plot(cg_position, 0, marker='o', color='green', markersize=8, label='CG')\n",
    "        ax.annotate(\"CG\", (cg_position, 0.3), color='green', ha='center')\n",
    "\n",
    "    # Plot NP\n",
    "    if np_position is not None:\n",
    "        ax.plot(np_position, 0, marker='^', color='purple', markersize=8, label='NP')\n",
    "        ax.annotate(\"NP\", (np_position, -0.3), color='purple', ha='center')\n",
    "\n",
    "    # Plot other components\n",
    "    if components:\n",
    "        for label, x in components.items():\n",
    "            ax.plot(x, 0, marker='s', color='black', markersize=6)\n",
    "            ax.annotate(label, (x, -1), ha='center', fontsize=8, rotation=90)\n",
    "\n",
    "    # Set limits and formatting\n",
    "    ax.set_aspect('equal')\n",
    "    ax.set_xlabel(\"X (m)\")\n",
    "    ax.set_ylabel(\"Y (m)\")\n",
    "    ax.set_title(\"Top View of UAV Layout with CG and NP\")\n",
    "\n",
    "    x_max = max(fuselage_length, wing_le_position + wing_chord, tail_le_position + tail_chord)\n",
    "    y_max = max(wing_span, tail_span) / 2\n",
    "\n",
    "    ax.set_xlim(-0.1 * fuselage_length, x_max * 1.1)\n",
    "    ax.set_ylim(-y_max * 1.2, y_max * 1.2)\n",
    "\n",
    "    ax.grid(True)\n",
    "    ax.legend()\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "85d4a13c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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euutphVBDwR0G3IegH7++edy9dVXm9dX97V+frXG/eOPPxZr20aMGCFVqlQp8ECuKL///rv5qfsCp4IAQWj48OFaZcm+P3/+fHN//Pjxuda75pprXCEhIa7NmzdnL9P19Pbjjz9mL/vzzz9dUVFRrn79+hX53P379zfrHj58OHvZ+vXrzWOOGjUqe9kff/xhlk2bNi17Wffu3V1t2rRxHT9+PHtZVlaW64ILLnA1a9YsV/lq1qyZff++++5zde7c2VWjRg3XlClTzLL9+/ebsr344ouFbm/fvn1d5cqVc/3+++/Zy3bt2uWqWLGiecy82/vMM88U+RosWbLErPvBBx94tH/cLr/8clenTp2y70+dOtUVHh7u2rdvX/ayAwcOuCIjI1033HBDrr8dOXKkecwNGzYUuX0NGzZ09enTp9B1UlNTT1s2adIk85rq+8FNt6NOnTquzMzM7GWrVq3KtW9Pnjxp9k3r1q1daWlp2estWLDArDd69OjsZRdffLG55TV48GCz3W5//fWX+dsxY8a4PFHS90xxnlfX1d898cQTuZa3a9fO1b59+0K3T59T/3bevHkeladKlSqutm3bnrY8JSXFbKP7dvTo0UIfJyMjw3XixIlcyw4ePGheq6FDh572/q9WrZp5D7p99NFHZvknn3ySvUy3q3bt2q5Dhw5lL/v888/Nejlfy4Lo/j/zzDPN/8eNG2f+7qeffirwc+j+vL311lumzPr5/fTTT12NGjUy+3PlypVFPqcNqOFb4rPPPjO1Bu3Pykmb+DXj844GP//883MNlNFm3SuvvNLUKotqmtRWgePHj5vam5u7xl9Y7VNrNzpgTWuB2nenTa5609qs1jb0lDh386/WwPbu3SsbNmww992D2HS5/t9dY9KyFVbD17JobURrIDqq16127dqmpqWPoTWgsuCutWsLgpu7lvT+++9nL9Maz2WXXWZaA7SbRmk5tctEuz+039Ibcvb96vPovtDBYvpcOZvwtca/a9euXE3AWrvXv9ftV1qz09Hkd9xxR65xGzrgTJuj8+sC8jZvvWc8oYPn8j53UaPF3e8zbcr2hK6f3ymA2uyvLRHu28MPP1zo4+j3gp4JoLTLTT+HeoaHvpfya0q/7rrrzHswZ9mUu3zazaAtAzoGRbsI3Hr27CmtWrWS4nLX8t0DJQujAx61zDqeSN9b+r7V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V155Rdq1a2f66m+55RZzcKAhnZcGdb169eSDDz4wYf7tt9/KP/7xDzP73bXXXmvWmTx5snlcbY3QAwk9IJg/f7507do1+3E07N955x157bXXpFmzZrJs2TIZNGiQabG4+OKLffqaEPgAgIC2YMECMy2u26WXXmqCuTAa8Frjvuqqq6R+/fpStWpVOf/887PPOBgzZow899xz5vdKa9zr1q2T119/Pd/A14vYjBs3Lvu+rv/dd9/J+++/nx34L7/8shmj0K9fP3NfDyY+++yz7L85ceKETJw4Ub744guzLUpbHpYvX26el8AHAFhNa8hTpkzJvq9hr8FaGG0q7969u2nS16b8iy66yNSktXauzfq///67aaLXWr2bHiBUqlSpwMd89dVX5a233jJnN6SlpZnpet0j+A8fPix79+6Vjh07Zq+vV7lr3769aR1QmzdvNoMke/bsmetx9XG0lcHXCHwAQEDTgM87Il9r6u7mebecU89q2CYmJpqm98WLF8vUqVNlwoQJ8v3332dPVfvGG2/Iueeem+sxCroU7axZs+SBBx4wrQJaO69YsaI888wz5vE8pRfwUZ9++qnUrVv3tHEKvkbgAwAcR/u8165dm2uZ9tFr03vOKWk7depkAnrEiBGm1j9v3jy57777pE6dOuY0wYEDB3r0fP/5z3/kggsukDvuuCN7mbYSuGnLQM2aNWXlypXSuXPn7IF+q1atym4F0DMhNNi1hcDXzff5IfABwHIafE57nm7dupka9ttvv20CXQfC6QGAu2lca95ffvmlac7X2f2WLl0qf/31lxlMp7Q/XkfUa1DraX/av/7jjz/KwYMHzQFBXjrATp9LWwu0//7f//63CXf9v9tdd91lBuVpa4SO+tc+fX0891z42iqgrQT33nuvaea/8MILTVeAHkzExsbmO3bAmwh8ALCUBqE2bxfVH+5N+nz6vKXVu3dvefzxx+Whhx6S48ePy9ChQ+XGG2+UX3/91fxeA1RHwL/wwguSkpJiBu49++yzZsCfuvnmm8226EHDgw8+aLoNtL9fT+3Lz6233mpG8l933XUmwPUMAK3tL1y4MHsdPQ1vz549Zju0a0BH8et25uwmePLJJ03rhB4Y6AGQnsJ39tlnyyOPPCK+RuADgKV0tjud5jaQ59KfPn16gb/TWnrOkfM5aU1+0aJF2WVJSUkxBwE5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/e9/N9esHz16tAnzwnzzzTfmstB5abi/9NJLJry1b1+7C/r162cOBD777DPZsmWLXH311eY67Nddd1323+nlpfXAA4B3EPgAThMSEiJTpkyRli1bSps2bUx/elH+/PPPfAM/PT3dPFaTJk3Mfa3h//vf/5a9e/dKhQoVpFWrVtK1a1dZsmRJrsCvU6eObN++3fTjh4bSGAmUFp8iAPl66623TBO89snv2LGjyPXT0tIkKirqtOX6GO6wVzVr1jRN+Rr2OZft27cv199FR0ebsD9x4kSpywKAwAeQj2+//Vb++c9/mr53bVofNmyYFDW+Ny4uTg4ePHja8oiIiNNaD/JblndE/oEDB6R8+fIm+AGUHoEP4LQ+9yFDhsjtt99umtp1pPwPP/wgr732WqF/165dO1m3bp3XtmPt2rXmMQF4B4EP4LRz6bU27x4wp83vzz77rDz00EOydevWAv+ud+/e8t133+UabV8aOgiwV69eXnksAAQ+gBy+/vprefXVV2XatGmm793t1ltvNRPyFNa0f+mll0p4eLh88cUXpd6OnTt3mm6Fm266qdSPBeAUJt4B4DV6sPDxxx/L4sWLS/U4Dz/8sBkPMHXqVK9tG2A7TssD4DXaEnDo0CFzvn1pptetUaOG3HfffV7dNsB21PABALAAffgAAFiAwAcAwAIEPgAAFiDwAQCwAIEPAIAFCHwAACxA4AMAYAECHwAACxD4AABI8Pt/KZUgxvUKP7gAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 3000x1000 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "components = estimate_component_positions(predrop[\"fuselage_body_length_m\"], predrop[\"wing_le_position_m\"], predrop[\"chord_m\"], \n",
    "                             predrop[\"tail_arm_m\"], hard_constraints[\"internal_payload_length\"], assumed_and_set[\"fuselage_fuel_tank_length\"], \n",
    "                             cg_estimate=predrop[\"cruiseout_cg_from_nose_m\"])\n",
    "\n",
    "# components = {\"avionics\":components[\"avionics\"], \"Payload\":components[\"internal_payload\"]}\n",
    "\n",
    "components = {}\n",
    "\n",
    "h_tail_le_position = predrop[\"cruiseout_cg_from_nose_m\"] + predrop[\"tail_arm_m\"] - 0.25 * predrop[\"h_tail_chord_m\"]\n",
    "\n",
    "plot_uav_top_view(\n",
    "    fuselage_length=predrop[\"fuselage_body_length_m\"],\n",
    "    fuselage_width=predrop[\"fuselage_body_width_m\"],\n",
    "    wing_span=predrop[\"wing_span_m\"],\n",
    "    wing_chord=predrop[\"chord_m\"],\n",
    "    wing_le_position=predrop[\"wing_le_position_m\"],\n",
    "    tail_span=predrop[\"h_tail_span_m\"],\n",
    "    tail_chord=predrop[\"h_tail_chord_m\"],\n",
    "    tail_le_position=h_tail_le_position,\n",
    "    components=components,\n",
    "    cg_position=predrop[\"cruiseout_cg_from_nose_m\"],\n",
    "    np_position=predrop[\"neutral_point_m\"],\n",
    ")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "id": "8836ad29",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'fuselage': 5.005870365706593,\n",
       " 'wing': 5.401860245640981,\n",
       " 'tails': 9.010566658271868,\n",
       " 'engine': 9.511153694842525,\n",
       " 'propeller': 10.011740731413186,\n",
       " 'wing_payload': 5.4458591211892475,\n",
       " 'wing_fuel': 5.401860245640981,\n",
       " 'fuselage_fuel': 4.7308703657065925,\n",
       " 'avionics': 1.0011740731413186,\n",
       " 'landing_gear': 4.921830136826953,\n",
       " 'misc': 5.923004209968272}"
      ]
     },
     "execution_count": 103,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "components"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bc47a0aa",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "uav",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
